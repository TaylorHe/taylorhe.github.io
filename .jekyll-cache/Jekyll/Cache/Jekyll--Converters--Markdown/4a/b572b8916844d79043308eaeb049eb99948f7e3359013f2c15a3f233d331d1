I"¶<p>Python 3.8 introduced a nice quality of life assignment expression denoted by ‚Äú:=‚Äù.  It‚Äôs also called the walrus operator because it looks like the eyes and tusks of a walrus on its side. It allows the writer to assign and return a variable in a single expression, which reduces the amount of code you actually have to write to do something. It‚Äôs much easier to see it in use. Let‚Äôs check out some examples!</p>

<p>When a calculated value is part of a conditional, it can be shortened inline with the conditional.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># No walrus
</span><span class="n">value</span> <span class="o">=</span> <span class="n">foo</span><span class="p">()</span>
<span class="k">if</span> <span class="n">value</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">bar</span><span class="p">(</span><span class="n">value</span><span class="p">)</span>

<span class="c1"># Walrus operator
</span><span class="k">if</span> <span class="p">(</span><span class="n">value</span> <span class="p">:</span><span class="o">=</span> <span class="n">foo</span><span class="p">())</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">bar</span><span class="p">(</span><span class="n">value</span><span class="p">)</span></code></pre></figure>

<p>You make your code for reading a file more concise as well.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># No walrus
</span><span class="n">block</span> <span class="o">=</span> <span class="nb">file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>
<span class="k">while</span> <span class="n">block</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">process</span><span class="p">(</span><span class="n">block</span><span class="p">)</span>
    <span class="n">block</span> <span class="o">=</span> <span class="nb">file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span>

<span class="c1"># Walrus operator
</span><span class="k">if</span> <span class="p">(</span><span class="n">block</span> <span class="p">:</span><span class="o">=</span> <span class="nb">file</span><span class="o">.</span><span class="n">readline</span><span class="p">()</span> <span class="ow">is</span> <span class="ow">not</span> <span class="bp">None</span><span class="p">:</span>
    <span class="n">process</span><span class="p">(</span><span class="n">block</span><span class="p">)</span></code></pre></figure>

<p>And finally, it can make expressions in list comprehension more efficient.</p>

<figure class="highlight"><pre><code class="language-python" data-lang="python"><span class="c1"># No walrus makes this list comprehension perform expensive_operation twice!
</span><span class="n">values</span> <span class="o">=</span> <span class="p">[</span><span class="mi">1</span><span class="p">,</span><span class="mi">2</span><span class="p">,</span><span class="mi">3</span><span class="p">,</span><span class="mi">4</span><span class="p">,</span><span class="mi">5</span><span class="p">,</span> <span class="o">...</span> <span class="p">]</span>  <span class="o">//</span> <span class="n">Some</span> <span class="n">random</span> <span class="nb">list</span>
<span class="p">[</span><span class="n">expensive_operation</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span> <span class="k">if</span> <span class="n">expensive_operation</span><span class="p">(</span><span class="n">v</span><span class="p">)</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span>

<span class="c1"># Walrus operator caches the result for you and therefore only computes once
</span><span class="p">[</span><span class="n">result</span> <span class="k">for</span> <span class="n">v</span> <span class="ow">in</span> <span class="n">values</span> <span class="k">if</span> <span class="p">(</span><span class="n">result</span> <span class="p">:</span><span class="o">=</span> <span class="n">expensive_operation</span><span class="p">(</span><span class="n">v</span><span class="p">))</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">]</span></code></pre></figure>

<p>This is actually a pretty controversial addition to Python, with critics arguing that assignment in the middle of an expression is ugly and complex, and now there‚Äôs ambiguity in assignments. There are more points to be made in the argument linked above, but overall I think it helps simply my code a ton, and I think this optimization of writing one line instead of a few is really nice.</p>
:ET