<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>Optional Chaining and Nullish Coalescing in Typescript 3.7 | Programbling</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="Optional Chaining and Nullish Coalescing in Typescript 3.7" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="It’s finally here, the day we’ve all been waiting for. Well, not exactly, as Typescript 3.7 was released November 5. It solves one of the most annoying issues of javascript: optional parameter chaining. There have been attempts at solving this problem in lodash, idx and other libraries, but it’s great that typescript now supports this functionality natively. Issue Let’s first describe the issue of accessing a nested object property. For an example, let’s take the decently nested object obj defined as follows: obj = { a: { b: { c: { d: &quot;hello world&quot;, dEmpty: &quot;&quot; } } }, e: { f: [{ g0: &quot;nice&quot; }] } } Any of the properties can be null or undefined, so how does one access property d? In pre-Typescript 3.7, it’s common practice to short circuit the conditional like so: if (obj &amp;&amp; obj.a &amp;&amp; obj.a.b &amp;&amp; obj.a.b.c &amp;&amp; obj.a.b.c.d) { console.log(obj.a.b.c.d); // hello world safely accessed } I’ve even seen other monstrosities when arrays are mixed in: if (obj &amp;&amp; obj.e &amp;&amp; obj.e.f) { if (Array.isArray(obj.e.f) &amp;&amp; obj.e.f.length &gt; 0) { if (obj.e.f[0].g0) { console.log(obj.e.f[0].g0); // =&gt; &quot;nice&quot; } } } Optional Chaining But those days are all over with Typescript 3.7’s optional chaining. Basically what it allows you to do is stop running an expression if one of the previous arguments is null or undefined. Now we can write the same expressions with the new syntax ?. can the above code can be condensed to: // Same as checking if each parameter along the chain is either null or undefined console.log(obj?.a?.b?.c?.d); // =&gt; &quot;hello world&quot; safely accessed console.log(obj?.a?.b?.c?.foo); // =&gt; returns undefined, and does not throw console.log(obj?.e?.f[0]?.g0) { // Safe access or undefined Nullish Coalescing If we combine this new feature with yet another great Typescript 3.7 feature, nullish coalescing, denoted by a ??, it can be a powerful tool. Null coalescing is to check if the expression given is null or undefined. undefined ?? &quot;default&quot; // =&gt; &quot;default&quot; null ?? &quot;default&quot; // =&gt; &quot;default&quot; &quot;&quot; ?? &quot;default&quot; // =&gt; &quot;&quot; It’s slightly different than the OR symbol ||, as that also checks if the expression is an empty string or 0. Combining them looks like this: console.log(obj?.a?.b?.c?.d ?? &quot;default value&quot;); // =&gt; &quot;hello world&quot; console.log(obj?.a?.foo?.c?.d ?? &quot;default value&quot;); // =&gt; &quot;default value&quot; console.log(obj?.a?.foo?.c?.dEmpty ?? &quot;default value&quot;); // =&gt; &quot;&quot; console.log(obj?.e?.f[0]?.g0 ?? &quot;default value&quot;); // =&gt; &quot;nice&quot; console.log(obj?.e?.f[42]?.g0 ?? &quot;default value&quot;); // =&gt; &quot;default value&quot; I’m really excited to start putting optional chaining to use." />
<meta property="og:description" content="It’s finally here, the day we’ve all been waiting for. Well, not exactly, as Typescript 3.7 was released November 5. It solves one of the most annoying issues of javascript: optional parameter chaining. There have been attempts at solving this problem in lodash, idx and other libraries, but it’s great that typescript now supports this functionality natively. Issue Let’s first describe the issue of accessing a nested object property. For an example, let’s take the decently nested object obj defined as follows: obj = { a: { b: { c: { d: &quot;hello world&quot;, dEmpty: &quot;&quot; } } }, e: { f: [{ g0: &quot;nice&quot; }] } } Any of the properties can be null or undefined, so how does one access property d? In pre-Typescript 3.7, it’s common practice to short circuit the conditional like so: if (obj &amp;&amp; obj.a &amp;&amp; obj.a.b &amp;&amp; obj.a.b.c &amp;&amp; obj.a.b.c.d) { console.log(obj.a.b.c.d); // hello world safely accessed } I’ve even seen other monstrosities when arrays are mixed in: if (obj &amp;&amp; obj.e &amp;&amp; obj.e.f) { if (Array.isArray(obj.e.f) &amp;&amp; obj.e.f.length &gt; 0) { if (obj.e.f[0].g0) { console.log(obj.e.f[0].g0); // =&gt; &quot;nice&quot; } } } Optional Chaining But those days are all over with Typescript 3.7’s optional chaining. Basically what it allows you to do is stop running an expression if one of the previous arguments is null or undefined. Now we can write the same expressions with the new syntax ?. can the above code can be condensed to: // Same as checking if each parameter along the chain is either null or undefined console.log(obj?.a?.b?.c?.d); // =&gt; &quot;hello world&quot; safely accessed console.log(obj?.a?.b?.c?.foo); // =&gt; returns undefined, and does not throw console.log(obj?.e?.f[0]?.g0) { // Safe access or undefined Nullish Coalescing If we combine this new feature with yet another great Typescript 3.7 feature, nullish coalescing, denoted by a ??, it can be a powerful tool. Null coalescing is to check if the expression given is null or undefined. undefined ?? &quot;default&quot; // =&gt; &quot;default&quot; null ?? &quot;default&quot; // =&gt; &quot;default&quot; &quot;&quot; ?? &quot;default&quot; // =&gt; &quot;&quot; It’s slightly different than the OR symbol ||, as that also checks if the expression is an empty string or 0. Combining them looks like this: console.log(obj?.a?.b?.c?.d ?? &quot;default value&quot;); // =&gt; &quot;hello world&quot; console.log(obj?.a?.foo?.c?.d ?? &quot;default value&quot;); // =&gt; &quot;default value&quot; console.log(obj?.a?.foo?.c?.dEmpty ?? &quot;default value&quot;); // =&gt; &quot;&quot; console.log(obj?.e?.f[0]?.g0 ?? &quot;default value&quot;); // =&gt; &quot;nice&quot; console.log(obj?.e?.f[42]?.g0 ?? &quot;default value&quot;); // =&gt; &quot;default value&quot; I’m really excited to start putting optional chaining to use." />
<link rel="canonical" href="http://localhost:4000/2019/12/25/opt-chain-null-coalesce.html" />
<meta property="og:url" content="http://localhost:4000/2019/12/25/opt-chain-null-coalesce.html" />
<meta property="og:site_name" content="Programbling" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2019-12-25T03:00:00-05:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2019/12/25/opt-chain-null-coalesce.html"},"datePublished":"2019-12-25T03:00:00-05:00","url":"http://localhost:4000/2019/12/25/opt-chain-null-coalesce.html","description":"It’s finally here, the day we’ve all been waiting for. Well, not exactly, as Typescript 3.7 was released November 5. It solves one of the most annoying issues of javascript: optional parameter chaining. There have been attempts at solving this problem in lodash, idx and other libraries, but it’s great that typescript now supports this functionality natively. Issue Let’s first describe the issue of accessing a nested object property. For an example, let’s take the decently nested object obj defined as follows: obj = { a: { b: { c: { d: &quot;hello world&quot;, dEmpty: &quot;&quot; } } }, e: { f: [{ g0: &quot;nice&quot; }] } } Any of the properties can be null or undefined, so how does one access property d? In pre-Typescript 3.7, it’s common practice to short circuit the conditional like so: if (obj &amp;&amp; obj.a &amp;&amp; obj.a.b &amp;&amp; obj.a.b.c &amp;&amp; obj.a.b.c.d) { console.log(obj.a.b.c.d); // hello world safely accessed } I’ve even seen other monstrosities when arrays are mixed in: if (obj &amp;&amp; obj.e &amp;&amp; obj.e.f) { if (Array.isArray(obj.e.f) &amp;&amp; obj.e.f.length &gt; 0) { if (obj.e.f[0].g0) { console.log(obj.e.f[0].g0); // =&gt; &quot;nice&quot; } } } Optional Chaining But those days are all over with Typescript 3.7’s optional chaining. Basically what it allows you to do is stop running an expression if one of the previous arguments is null or undefined. Now we can write the same expressions with the new syntax ?. can the above code can be condensed to: // Same as checking if each parameter along the chain is either null or undefined console.log(obj?.a?.b?.c?.d); // =&gt; &quot;hello world&quot; safely accessed console.log(obj?.a?.b?.c?.foo); // =&gt; returns undefined, and does not throw console.log(obj?.e?.f[0]?.g0) { // Safe access or undefined Nullish Coalescing If we combine this new feature with yet another great Typescript 3.7 feature, nullish coalescing, denoted by a ??, it can be a powerful tool. Null coalescing is to check if the expression given is null or undefined. undefined ?? &quot;default&quot; // =&gt; &quot;default&quot; null ?? &quot;default&quot; // =&gt; &quot;default&quot; &quot;&quot; ?? &quot;default&quot; // =&gt; &quot;&quot; It’s slightly different than the OR symbol ||, as that also checks if the expression is an empty string or 0. Combining them looks like this: console.log(obj?.a?.b?.c?.d ?? &quot;default value&quot;); // =&gt; &quot;hello world&quot; console.log(obj?.a?.foo?.c?.d ?? &quot;default value&quot;); // =&gt; &quot;default value&quot; console.log(obj?.a?.foo?.c?.dEmpty ?? &quot;default value&quot;); // =&gt; &quot;&quot; console.log(obj?.e?.f[0]?.g0 ?? &quot;default value&quot;); // =&gt; &quot;nice&quot; console.log(obj?.e?.f[42]?.g0 ?? &quot;default value&quot;); // =&gt; &quot;default value&quot; I’m really excited to start putting optional chaining to use.","headline":"Optional Chaining and Nullish Coalescing in Typescript 3.7","dateModified":"2019-12-25T03:00:00-05:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Programbling" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Programbling</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">Optional Chaining and Nullish Coalescing in Typescript 3.7</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2019-12-25T03:00:00-05:00" itemprop="datePublished">Dec 25, 2019
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>It’s finally here, the day we’ve all been waiting for. Well, not exactly, as Typescript 3.7 was released November 5. It solves one of the most annoying issues of javascript: optional parameter chaining. There have been attempts at solving this problem in <a href="https://lodash.com/">lodash</a>, <a href="https://github.com/facebookincubator/idx">idx</a> and other libraries, but it’s great that typescript now supports this functionality natively.</p>

<h3 id="issue">Issue</h3>
<p>Let’s first describe the issue of accessing a nested object property. For an example, let’s take the decently nested object obj defined as follows:</p>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript"><span class="nx">obj</span> <span class="o">=</span> <span class="p">{</span>
    <span class="na">a</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">b</span><span class="p">:</span> <span class="p">{</span>
            <span class="na">c</span><span class="p">:</span> <span class="p">{</span>
                <span class="na">d</span><span class="p">:</span> <span class="dl">"</span><span class="s2">hello world</span><span class="dl">"</span><span class="p">,</span>
                <span class="na">dEmpty</span><span class="p">:</span> <span class="dl">""</span>
            <span class="p">}</span>
        <span class="p">}</span>
    <span class="p">},</span>
    <span class="na">e</span><span class="p">:</span> <span class="p">{</span>
        <span class="na">f</span><span class="p">:</span> <span class="p">[{</span> <span class="na">g0</span><span class="p">:</span> <span class="dl">"</span><span class="s2">nice</span><span class="dl">"</span> <span class="p">}]</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<p>Any of the properties can be null or undefined, so how does one access property d? In pre-Typescript 3.7, it’s common practice to short circuit the conditional like so:</p>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript"><span class="k">if</span> <span class="p">(</span><span class="nx">obj</span> 
    <span class="o">&amp;&amp;</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">a</span> 
    <span class="o">&amp;&amp;</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">b</span> 
    <span class="o">&amp;&amp;</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">c</span>
    <span class="o">&amp;&amp;</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">c</span><span class="p">.</span><span class="nx">d</span><span class="p">)</span> <span class="p">{</span>
    <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">a</span><span class="p">.</span><span class="nx">b</span><span class="p">.</span><span class="nx">c</span><span class="p">.</span><span class="nx">d</span><span class="p">);</span>  <span class="c1">// hello world safely accessed
</span>
<span class="p">}</span></code></pre></figure>

<p>I’ve even seen other monstrosities when arrays are mixed in:</p>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript"><span class="k">if</span> <span class="p">(</span><span class="nx">obj</span> <span class="o">&amp;&amp;</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">e</span> <span class="o">&amp;&amp;</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">e</span><span class="p">.</span><span class="nx">f</span><span class="p">)</span> <span class="p">{</span>
    <span class="k">if</span> <span class="p">(</span><span class="nb">Array</span><span class="p">.</span><span class="nx">isArray</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">e</span><span class="p">.</span><span class="nx">f</span><span class="p">)</span> <span class="o">&amp;&amp;</span> <span class="nx">obj</span><span class="p">.</span><span class="nx">e</span><span class="p">.</span><span class="nx">f</span><span class="p">.</span><span class="nx">length</span> <span class="o">&gt;</span> <span class="mi">0</span><span class="p">)</span> <span class="p">{</span>
        <span class="k">if</span> <span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">e</span><span class="p">.</span><span class="nx">f</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">g0</span><span class="p">)</span> <span class="p">{</span>
            <span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">.</span><span class="nx">e</span><span class="p">.</span><span class="nx">f</span><span class="p">[</span><span class="mi">0</span><span class="p">].</span><span class="nx">g0</span><span class="p">);</span>  <span class="c1">// =&gt; "nice"
</span>
        <span class="p">}</span>
    <span class="p">}</span>
<span class="p">}</span></code></pre></figure>

<h3 id="optional-chaining">Optional Chaining</h3>
<p>But those days are all over with Typescript 3.7’s optional chaining. Basically what it allows you to do is stop running an expression if one of the previous arguments is null or undefined.</p>

<p>Now we can write the same expressions with the new syntax <code class="highlighter-rouge">?.</code> can the above code can be condensed to:</p>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript"><span class="c1">// Same as checking if each parameter along the chain is either null or undefined
</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">?.</span><span class="nx">a</span><span class="p">?.</span><span class="nx">b</span><span class="p">?.</span><span class="nx">c</span><span class="p">?.</span><span class="nx">d</span><span class="p">);</span>    <span class="c1">// =&gt; "hello world" safely accessed
</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">?.</span><span class="nx">a</span><span class="p">?.</span><span class="nx">b</span><span class="p">?.</span><span class="nx">c</span><span class="p">?.</span><span class="nx">foo</span><span class="p">);</span>  <span class="c1">// =&gt; returns undefined, and does not throw
</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">?.</span><span class="nx">e</span><span class="p">?.</span><span class="nx">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]?.</span><span class="nx">g0</span><span class="p">)</span> <span class="p">{</span>  <span class="c1">// Safe access or undefined</span></code></pre></figure>

<p>Nullish Coalescing
If we combine this new feature with yet another great Typescript 3.7 feature, nullish coalescing, denoted by a <code class="highlighter-rouge">??</code>, it can be a powerful tool. Null coalescing is to check if the expression given is null or undefined.</p>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript"><span class="kc">undefined</span> <span class="p">??</span> <span class="dl">"</span><span class="s2">default</span><span class="dl">"</span>  <span class="c1">// =&gt; "default"
</span>
<span class="kc">null</span> <span class="p">??</span> <span class="dl">"</span><span class="s2">default</span><span class="dl">"</span>       <span class="c1">// =&gt; "default"
</span>
<span class="dl">""</span> <span class="p">??</span> <span class="dl">"</span><span class="s2">default</span><span class="dl">"</span>         <span class="c1">// =&gt; ""</span></code></pre></figure>

<p>It’s slightly different than the OR symbol <code class="highlighter-rouge">||</code>, as that also checks if the expression is an empty string or 0. Combining them looks like this:</p>

<figure class="highlight"><pre><code class="language-typescript" data-lang="typescript"><span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">?.</span><span class="nx">a</span><span class="p">?.</span><span class="nx">b</span><span class="p">?.</span><span class="nx">c</span><span class="p">?.</span><span class="nx">d</span> <span class="p">??</span> <span class="dl">"</span><span class="s2">default value</span><span class="dl">"</span><span class="p">);</span>  <span class="c1">// =&gt; "hello world"
</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">?.</span><span class="nx">a</span><span class="p">?.</span><span class="nx">foo</span><span class="p">?.</span><span class="nx">c</span><span class="p">?.</span><span class="nx">d</span> <span class="p">??</span> <span class="dl">"</span><span class="s2">default value</span><span class="dl">"</span><span class="p">);</span>  <span class="c1">// =&gt; "default value"
</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">?.</span><span class="nx">a</span><span class="p">?.</span><span class="nx">foo</span><span class="p">?.</span><span class="nx">c</span><span class="p">?.</span><span class="nx">dEmpty</span> <span class="p">??</span> <span class="dl">"</span><span class="s2">default value</span><span class="dl">"</span><span class="p">);</span>  <span class="c1">// =&gt; ""
</span>

<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">?.</span><span class="nx">e</span><span class="p">?.</span><span class="nx">f</span><span class="p">[</span><span class="mi">0</span><span class="p">]?.</span><span class="nx">g0</span> <span class="p">??</span> <span class="dl">"</span><span class="s2">default value</span><span class="dl">"</span><span class="p">);</span>  <span class="c1">// =&gt; "nice"
</span>
<span class="nx">console</span><span class="p">.</span><span class="nx">log</span><span class="p">(</span><span class="nx">obj</span><span class="p">?.</span><span class="nx">e</span><span class="p">?.</span><span class="nx">f</span><span class="p">[</span><span class="mi">42</span><span class="p">]?.</span><span class="nx">g0</span> <span class="p">??</span> <span class="dl">"</span><span class="s2">default value</span><span class="dl">"</span><span class="p">);</span>  <span class="c1">// =&gt; "default value"</span></code></pre></figure>

<p>I’m really excited to start putting optional chaining to use.</p>

  </div><a class="u-url" href="/2019/12/25/opt-chain-null-coalesce.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Programbling</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Programbling</li><li><a class="u-email" href="mailto:taylor.he7@gmail.com">taylor.he7@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/taylorhe"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">taylorhe</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>I ramble about programming and other topics.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
