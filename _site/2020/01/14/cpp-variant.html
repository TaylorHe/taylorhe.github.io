<!DOCTYPE html>
<html lang="en"><head>
  <meta charset="utf-8">
  <meta http-equiv="X-UA-Compatible" content="IE=edge">
  <meta name="viewport" content="width=device-width, initial-scale=1"><!-- Begin Jekyll SEO tag v2.6.1 -->
<title>C++ Variant | Programbling</title>
<meta name="generator" content="Jekyll v4.0.0" />
<meta property="og:title" content="C++ Variant" />
<meta property="og:locale" content="en_US" />
<meta name="description" content="I haven’t used unions in C++ because they’re just not intuitive enough to me. They’re horrendous to write and a pain to maintain. Let’s go over what they are. A union is a special class type that can only hold one of its members at a time. It’s similar to a struct declaration. Take the following sample code from cppreference. I’ve added some of my thoughts. union S { std::string str; std::vector&lt;int&gt; vec; ~S() {} // needs to know which member is active, only possible in union-like class }; // the whole union occupies max(sizeof(string), sizeof(vector)) int main() { S s = {&quot;Hello world&quot;}; /* Okay, so we can set this choice type to a string Actually, this just sets the value to the first type. Looks like order matters. At this point, reading from s.vec is undefined behavior Shouldn&#39;t reading from s.vec throw an error or something? */ std::cout &lt;&lt; &quot;s.str = &quot; &lt;&lt; s.str &lt;&lt; &#39;\n&#39;; s.str.~basic_string(); // uhm, destroying the string with its literal destructor? /* s = { std::vector&lt;int&gt;{12,34} }; We can&#39;t this op, which is pretty unintuitive since we could handle the string case. */ new (&amp;s.vec) std::vector&lt;int&gt;; // now, s.vec is the active member of the union s.vec.push_back(10); std::cout &lt;&lt; s.vec.size() &lt;&lt; &#39;\n&#39;; s.vec.~vector(); // another destructor! } To me, it makes little sense for the developer using union to control so much of the nitty gritty. Huge points against using this at all are: There’s no way to check the active type, making the program keep state of the union separately, The developer must explicitly call the constructors and destructor of the contained objects to manage internal state. There’s no consistency in setting the value Limitations, described by cppreference: no virtual functions allowed cannot have base classes cannot be used as a base class cannot have non-static data members of reference types Union just seems like a super clunky, crude implementation of a lower-level type, but finally C++17 improves on this: Introducing the new and improved std::variant! std::variant Unrelated to statistical variance mentioned in my [deleted] previous post, the std::variant is a new feature in the C++17 standard library. It’s similar to the existing boost::variant. We can define union or choice types with a more comprehensive solution. Let’s see if this is something that sucks a little less, shall we? int main() { std::variant&lt;std::vector&lt;int&gt;, std::string&gt; mVariant; mVariant = &quot;hello world&quot;; // We can match types without it being the first one! std::cout &lt;&lt; mVariant.index() &lt;&lt; std::endl; // &quot;1&quot;, the index in the template mVariant = std::vector{1, 2, 3}; /* We can change the value without manually calling the destructor! Setting the value makes sense with the assignment operator */ mVariant = &quot;this is so much better already&quot;; /* index() does a good enough job, but there&#39;s also other ways to satiate your value getting needs std::get() could throw std::bad_variant_access, while std::get_if() does not throw */ auto strPtr = std::get&lt;std::string&gt;(mVariant); std::cout &lt;&lt; *strPtr &lt;&lt; std::endl; auto strPtr = std::get_if&lt;std::string&gt;(mVariant); if (strPtr) { std::cout &lt;&lt; *strPtr &lt;&lt; std::endl; } /* We don&#39;t have to get the value to check the value. std also has holds_alternative: */ if (std::holds_alternative&lt;std::string&gt;(mVariant)) { std::cout &lt;&lt; &quot;variant holds a string&quot; &lt;&lt; std::endl; } /* We can also change the values other ways: */ mVariant.emplace&lt;1&gt;(std::string(&quot;emplace me&quot;)); /* Because get() returns a reference, we can do things like */ std::get&lt;std::string&gt;(mVariant) += &quot; append me&quot;; } I’d say that this is a much more mature and featured implementation of the choice type wanted. There are a few great things about std::variant: If you haven’t noticed, all the getters are type safe. You can figure out the current type with holds_alternative() and index() You don’t have to manually call constructors/destructors, even on non-trival types. There’s no extra memory allocation besides the one for std::variant itself, which can stay on the stack; no heap allocations except for the held object itself. std::visit std::visit is a function that applies a function, called a “Visitor”, on a std::variant. Visitors are used to It’s easier to see in an example than it is to explain in words. int main() { auto PrintVisitor = [](const auto&amp; type) { std:: cout &lt;&lt; type &lt;&lt; &quot; visited&quot;; }; std::variant&lt;int, double&gt; mVariant { 1 }; std::visit(PrintVisitor, mVariant); // prints &quot;1 visited&quot; /* We can selectively modify a variant based on its type through a struct */ struct MathVisitor { /* if int value, multiply by 2. if float, multiply by 1.5 */ void operator()(int&amp; i) const { i *= 2; } void operator()(float&amp; f) const { f *= 1.5f; } } std::visit(MathVisitor(), mVariant); // mVariant holds an int value of 2 std::visit(PrintVisitor, mVariant); // prints &quot;2 visited&quot; There’s only a few places std::variant actually comes into use that I can think of, so it’s not the most useful thing in the world. Only a few niche circumstances come to mind: Error handling: returning either the success value or an error. Using them to handle an object that might be defined by a string name or int id ??? I have some issues with the visitor function. It still feels a little clunky and verbose. There’s still some refinement to be done here, but overall, I think std::variant and friends are a great replacement for union." />
<meta property="og:description" content="I haven’t used unions in C++ because they’re just not intuitive enough to me. They’re horrendous to write and a pain to maintain. Let’s go over what they are. A union is a special class type that can only hold one of its members at a time. It’s similar to a struct declaration. Take the following sample code from cppreference. I’ve added some of my thoughts. union S { std::string str; std::vector&lt;int&gt; vec; ~S() {} // needs to know which member is active, only possible in union-like class }; // the whole union occupies max(sizeof(string), sizeof(vector)) int main() { S s = {&quot;Hello world&quot;}; /* Okay, so we can set this choice type to a string Actually, this just sets the value to the first type. Looks like order matters. At this point, reading from s.vec is undefined behavior Shouldn&#39;t reading from s.vec throw an error or something? */ std::cout &lt;&lt; &quot;s.str = &quot; &lt;&lt; s.str &lt;&lt; &#39;\n&#39;; s.str.~basic_string(); // uhm, destroying the string with its literal destructor? /* s = { std::vector&lt;int&gt;{12,34} }; We can&#39;t this op, which is pretty unintuitive since we could handle the string case. */ new (&amp;s.vec) std::vector&lt;int&gt;; // now, s.vec is the active member of the union s.vec.push_back(10); std::cout &lt;&lt; s.vec.size() &lt;&lt; &#39;\n&#39;; s.vec.~vector(); // another destructor! } To me, it makes little sense for the developer using union to control so much of the nitty gritty. Huge points against using this at all are: There’s no way to check the active type, making the program keep state of the union separately, The developer must explicitly call the constructors and destructor of the contained objects to manage internal state. There’s no consistency in setting the value Limitations, described by cppreference: no virtual functions allowed cannot have base classes cannot be used as a base class cannot have non-static data members of reference types Union just seems like a super clunky, crude implementation of a lower-level type, but finally C++17 improves on this: Introducing the new and improved std::variant! std::variant Unrelated to statistical variance mentioned in my [deleted] previous post, the std::variant is a new feature in the C++17 standard library. It’s similar to the existing boost::variant. We can define union or choice types with a more comprehensive solution. Let’s see if this is something that sucks a little less, shall we? int main() { std::variant&lt;std::vector&lt;int&gt;, std::string&gt; mVariant; mVariant = &quot;hello world&quot;; // We can match types without it being the first one! std::cout &lt;&lt; mVariant.index() &lt;&lt; std::endl; // &quot;1&quot;, the index in the template mVariant = std::vector{1, 2, 3}; /* We can change the value without manually calling the destructor! Setting the value makes sense with the assignment operator */ mVariant = &quot;this is so much better already&quot;; /* index() does a good enough job, but there&#39;s also other ways to satiate your value getting needs std::get() could throw std::bad_variant_access, while std::get_if() does not throw */ auto strPtr = std::get&lt;std::string&gt;(mVariant); std::cout &lt;&lt; *strPtr &lt;&lt; std::endl; auto strPtr = std::get_if&lt;std::string&gt;(mVariant); if (strPtr) { std::cout &lt;&lt; *strPtr &lt;&lt; std::endl; } /* We don&#39;t have to get the value to check the value. std also has holds_alternative: */ if (std::holds_alternative&lt;std::string&gt;(mVariant)) { std::cout &lt;&lt; &quot;variant holds a string&quot; &lt;&lt; std::endl; } /* We can also change the values other ways: */ mVariant.emplace&lt;1&gt;(std::string(&quot;emplace me&quot;)); /* Because get() returns a reference, we can do things like */ std::get&lt;std::string&gt;(mVariant) += &quot; append me&quot;; } I’d say that this is a much more mature and featured implementation of the choice type wanted. There are a few great things about std::variant: If you haven’t noticed, all the getters are type safe. You can figure out the current type with holds_alternative() and index() You don’t have to manually call constructors/destructors, even on non-trival types. There’s no extra memory allocation besides the one for std::variant itself, which can stay on the stack; no heap allocations except for the held object itself. std::visit std::visit is a function that applies a function, called a “Visitor”, on a std::variant. Visitors are used to It’s easier to see in an example than it is to explain in words. int main() { auto PrintVisitor = [](const auto&amp; type) { std:: cout &lt;&lt; type &lt;&lt; &quot; visited&quot;; }; std::variant&lt;int, double&gt; mVariant { 1 }; std::visit(PrintVisitor, mVariant); // prints &quot;1 visited&quot; /* We can selectively modify a variant based on its type through a struct */ struct MathVisitor { /* if int value, multiply by 2. if float, multiply by 1.5 */ void operator()(int&amp; i) const { i *= 2; } void operator()(float&amp; f) const { f *= 1.5f; } } std::visit(MathVisitor(), mVariant); // mVariant holds an int value of 2 std::visit(PrintVisitor, mVariant); // prints &quot;2 visited&quot; There’s only a few places std::variant actually comes into use that I can think of, so it’s not the most useful thing in the world. Only a few niche circumstances come to mind: Error handling: returning either the success value or an error. Using them to handle an object that might be defined by a string name or int id ??? I have some issues with the visitor function. It still feels a little clunky and verbose. There’s still some refinement to be done here, but overall, I think std::variant and friends are a great replacement for union." />
<link rel="canonical" href="http://localhost:4000/2020/01/14/cpp-variant.html" />
<meta property="og:url" content="http://localhost:4000/2020/01/14/cpp-variant.html" />
<meta property="og:site_name" content="Programbling" />
<meta property="og:type" content="article" />
<meta property="article:published_time" content="2020-01-14T03:00:00-05:00" />
<script type="application/ld+json">
{"@type":"BlogPosting","mainEntityOfPage":{"@type":"WebPage","@id":"http://localhost:4000/2020/01/14/cpp-variant.html"},"datePublished":"2020-01-14T03:00:00-05:00","url":"http://localhost:4000/2020/01/14/cpp-variant.html","description":"I haven’t used unions in C++ because they’re just not intuitive enough to me. They’re horrendous to write and a pain to maintain. Let’s go over what they are. A union is a special class type that can only hold one of its members at a time. It’s similar to a struct declaration. Take the following sample code from cppreference. I’ve added some of my thoughts. union S { std::string str; std::vector&lt;int&gt; vec; ~S() {} // needs to know which member is active, only possible in union-like class }; // the whole union occupies max(sizeof(string), sizeof(vector)) int main() { S s = {&quot;Hello world&quot;}; /* Okay, so we can set this choice type to a string Actually, this just sets the value to the first type. Looks like order matters. At this point, reading from s.vec is undefined behavior Shouldn&#39;t reading from s.vec throw an error or something? */ std::cout &lt;&lt; &quot;s.str = &quot; &lt;&lt; s.str &lt;&lt; &#39;\\n&#39;; s.str.~basic_string(); // uhm, destroying the string with its literal destructor? /* s = { std::vector&lt;int&gt;{12,34} }; We can&#39;t this op, which is pretty unintuitive since we could handle the string case. */ new (&amp;s.vec) std::vector&lt;int&gt;; // now, s.vec is the active member of the union s.vec.push_back(10); std::cout &lt;&lt; s.vec.size() &lt;&lt; &#39;\\n&#39;; s.vec.~vector(); // another destructor! } To me, it makes little sense for the developer using union to control so much of the nitty gritty. Huge points against using this at all are: There’s no way to check the active type, making the program keep state of the union separately, The developer must explicitly call the constructors and destructor of the contained objects to manage internal state. There’s no consistency in setting the value Limitations, described by cppreference: no virtual functions allowed cannot have base classes cannot be used as a base class cannot have non-static data members of reference types Union just seems like a super clunky, crude implementation of a lower-level type, but finally C++17 improves on this: Introducing the new and improved std::variant! std::variant Unrelated to statistical variance mentioned in my [deleted] previous post, the std::variant is a new feature in the C++17 standard library. It’s similar to the existing boost::variant. We can define union or choice types with a more comprehensive solution. Let’s see if this is something that sucks a little less, shall we? int main() { std::variant&lt;std::vector&lt;int&gt;, std::string&gt; mVariant; mVariant = &quot;hello world&quot;; // We can match types without it being the first one! std::cout &lt;&lt; mVariant.index() &lt;&lt; std::endl; // &quot;1&quot;, the index in the template mVariant = std::vector{1, 2, 3}; /* We can change the value without manually calling the destructor! Setting the value makes sense with the assignment operator */ mVariant = &quot;this is so much better already&quot;; /* index() does a good enough job, but there&#39;s also other ways to satiate your value getting needs std::get() could throw std::bad_variant_access, while std::get_if() does not throw */ auto strPtr = std::get&lt;std::string&gt;(mVariant); std::cout &lt;&lt; *strPtr &lt;&lt; std::endl; auto strPtr = std::get_if&lt;std::string&gt;(mVariant); if (strPtr) { std::cout &lt;&lt; *strPtr &lt;&lt; std::endl; } /* We don&#39;t have to get the value to check the value. std also has holds_alternative: */ if (std::holds_alternative&lt;std::string&gt;(mVariant)) { std::cout &lt;&lt; &quot;variant holds a string&quot; &lt;&lt; std::endl; } /* We can also change the values other ways: */ mVariant.emplace&lt;1&gt;(std::string(&quot;emplace me&quot;)); /* Because get() returns a reference, we can do things like */ std::get&lt;std::string&gt;(mVariant) += &quot; append me&quot;; } I’d say that this is a much more mature and featured implementation of the choice type wanted. There are a few great things about std::variant: If you haven’t noticed, all the getters are type safe. You can figure out the current type with holds_alternative() and index() You don’t have to manually call constructors/destructors, even on non-trival types. There’s no extra memory allocation besides the one for std::variant itself, which can stay on the stack; no heap allocations except for the held object itself. std::visit std::visit is a function that applies a function, called a “Visitor”, on a std::variant. Visitors are used to It’s easier to see in an example than it is to explain in words. int main() { auto PrintVisitor = [](const auto&amp; type) { std:: cout &lt;&lt; type &lt;&lt; &quot; visited&quot;; }; std::variant&lt;int, double&gt; mVariant { 1 }; std::visit(PrintVisitor, mVariant); // prints &quot;1 visited&quot; /* We can selectively modify a variant based on its type through a struct */ struct MathVisitor { /* if int value, multiply by 2. if float, multiply by 1.5 */ void operator()(int&amp; i) const { i *= 2; } void operator()(float&amp; f) const { f *= 1.5f; } } std::visit(MathVisitor(), mVariant); // mVariant holds an int value of 2 std::visit(PrintVisitor, mVariant); // prints &quot;2 visited&quot; There’s only a few places std::variant actually comes into use that I can think of, so it’s not the most useful thing in the world. Only a few niche circumstances come to mind: Error handling: returning either the success value or an error. Using them to handle an object that might be defined by a string name or int id ??? I have some issues with the visitor function. It still feels a little clunky and verbose. There’s still some refinement to be done here, but overall, I think std::variant and friends are a great replacement for union.","headline":"C++ Variant","dateModified":"2020-01-14T03:00:00-05:00","@context":"https://schema.org"}</script>
<!-- End Jekyll SEO tag -->
<link rel="stylesheet" href="/assets/main.css"><link type="application/atom+xml" rel="alternate" href="http://localhost:4000/feed.xml" title="Programbling" /></head>
<body><header class="site-header" role="banner">

  <div class="wrapper"><a class="site-title" rel="author" href="/">Programbling</a><nav class="site-nav">
        <input type="checkbox" id="nav-trigger" class="nav-trigger" />
        <label for="nav-trigger">
          <span class="menu-icon">
            <svg viewBox="0 0 18 15" width="18px" height="15px">
              <path d="M18,1.484c0,0.82-0.665,1.484-1.484,1.484H1.484C0.665,2.969,0,2.304,0,1.484l0,0C0,0.665,0.665,0,1.484,0 h15.032C17.335,0,18,0.665,18,1.484L18,1.484z M18,7.516C18,8.335,17.335,9,16.516,9H1.484C0.665,9,0,8.335,0,7.516l0,0 c0-0.82,0.665-1.484,1.484-1.484h15.032C17.335,6.031,18,6.696,18,7.516L18,7.516z M18,13.516C18,14.335,17.335,15,16.516,15H1.484 C0.665,15,0,14.335,0,13.516l0,0c0-0.82,0.665-1.483,1.484-1.483h15.032C17.335,12.031,18,12.695,18,13.516L18,13.516z"/>
            </svg>
          </span>
        </label>

        <div class="trigger"><a class="page-link" href="/about/">About</a></div>
      </nav></div>
</header>
<main class="page-content" aria-label="Content">
      <div class="wrapper">
        <article class="post h-entry" itemscope itemtype="http://schema.org/BlogPosting">

  <header class="post-header">
    <h1 class="post-title p-name" itemprop="name headline">C++ Variant</h1>
    <p class="post-meta">
      <time class="dt-published" datetime="2020-01-14T03:00:00-05:00" itemprop="datePublished">Jan 14, 2020
      </time></p>
  </header>

  <div class="post-content e-content" itemprop="articleBody">
    <p>I haven’t used unions in C++ because they’re just not intuitive enough to me. They’re horrendous to write and a pain to maintain. Let’s go over what they are.</p>

<p>A <code class="highlighter-rouge">union</code> is a special class type that can only hold one of its members at a time. It’s similar to a <code class="highlighter-rouge">struct</code> declaration. Take the following sample code from <a href="https://en.cppreference.com/w/cpp/language/union">cppreference</a>. I’ve added some of my thoughts.</p>

<figure class="highlight"><pre><code class="language-c--" data-lang="c++"><span class="k">union</span> <span class="n">S</span> <span class="p">{</span>
   <span class="n">std</span><span class="o">::</span><span class="n">string</span> <span class="n">str</span><span class="p">;</span>
   <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span> <span class="n">vec</span><span class="p">;</span>
   <span class="o">~</span><span class="n">S</span><span class="p">()</span> <span class="p">{}</span> <span class="c1">// needs to know which member is active, only possible in union-like class
</span>
<span class="p">};</span>  <span class="c1">// the whole union occupies max(sizeof(string), sizeof(vector))
</span>
<span class="kt">int</span> <span class="nf">main</span><span class="p">()</span>
<span class="p">{</span>
    <span class="n">S</span> <span class="n">s</span> <span class="o">=</span> <span class="p">{</span><span class="s">"Hello world"</span><span class="p">};</span>
    <span class="cm">/*
    Okay, so we can set this choice type to a string
    Actually, this just sets the value to the first type. Looks like order matters.
    At this point, reading from s.vec is undefined behavior
    Shouldn't reading from s.vec throw an error or something?
    */</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"s.str = "</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">str</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">s</span><span class="p">.</span><span class="n">str</span><span class="p">.</span><span class="o">~</span><span class="n">basic_string</span><span class="p">();</span>  <span class="c1">// uhm, destroying the string with its literal destructor?
</span>
    <span class="cm">/*
    s = { std::vector&lt;int&gt;{12,34} };
    We can't this op, which is pretty unintuitive
    since we could handle the string case.
    */</span>
    <span class="k">new</span> <span class="p">(</span><span class="o">&amp;</span><span class="n">s</span><span class="p">.</span><span class="n">vec</span><span class="p">)</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">;</span>
    <span class="c1">// now, s.vec is the active member of the union
</span>
    <span class="n">s</span><span class="p">.</span><span class="n">vec</span><span class="p">.</span><span class="n">push_back</span><span class="p">(</span><span class="mi">10</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">s</span><span class="p">.</span><span class="n">vec</span><span class="p">.</span><span class="n">size</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="sc">'\n'</span><span class="p">;</span>
    <span class="n">s</span><span class="p">.</span><span class="n">vec</span><span class="p">.</span><span class="o">~</span><span class="n">vector</span><span class="p">();</span> <span class="c1">// another destructor!
</span>
<span class="p">}</span></code></pre></figure>

<p>To me, it makes little sense for the developer using union to control so much of the nitty gritty. Huge points against using this at all are:</p>
<ul>
  <li>There’s no way to check the active type, making the program keep state of the union separately,</li>
  <li>The developer must explicitly call the constructors and destructor of the contained objects to manage internal state.</li>
  <li>There’s no consistency in setting the value</li>
</ul>

<p>Limitations, described by cppreference:</p>
<ul>
  <li>no virtual functions allowed</li>
  <li>cannot have base classes</li>
  <li>cannot be used as a base class</li>
  <li>cannot have non-static data members of reference types
Union just seems like a super clunky, crude implementation of a lower-level type, but finally C++17 improves on this: Introducing the new and improved <code class="highlighter-rouge">std::variant</code>!</li>
</ul>

<h3 id="stdvariant">std::variant</h3>
<p>Unrelated to statistical variance mentioned in my [deleted] previous post, the <code class="highlighter-rouge">std::variant</code> is a new feature in the C++17 standard library. It’s similar to the existing <code class="highlighter-rouge">boost::variant</code>. We can define union or choice types with a more comprehensive solution.</p>

<p>Let’s see if this is something that sucks a little less, shall we?</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="o">&lt;</span><span class="kt">int</span><span class="o">&gt;</span><span class="p">,</span> <span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span> <span class="n">mVariant</span><span class="p">;</span>
    <span class="n">mVariant</span> <span class="o">=</span> <span class="s">"hello world"</span><span class="p">;</span>  <span class="c1">// We can match types without it being the first one!
</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">mVariant</span><span class="p">.</span><span class="n">index</span><span class="p">()</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>  <span class="c1">// "1", the index in the template
</span>
    <span class="n">mVariant</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">vector</span><span class="p">{</span><span class="mi">1</span><span class="p">,</span> <span class="mi">2</span><span class="p">,</span> <span class="mi">3</span><span class="p">};</span>
    <span class="cm">/* We can change the value without manually calling the destructor!
    Setting the value makes sense with the assignment operator */</span>
    <span class="n">mVariant</span> <span class="o">=</span> <span class="s">"this is so much better already"</span><span class="p">;</span>

    <span class="cm">/* index() does a good enough job, but there's also
    other ways to satiate your value getting needs 
        std::get() could throw std::bad_variant_access, while
        std::get_if() does not throw */</span>
    <span class="k">auto</span> <span class="n">strPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mVariant</span><span class="p">);</span>
    <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">strPtr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="k">auto</span> <span class="n">strPtr</span> <span class="o">=</span> <span class="n">std</span><span class="o">::</span><span class="n">get_if</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mVariant</span><span class="p">);</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">strPtr</span><span class="p">)</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="o">*</span><span class="n">strPtr</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>
    <span class="cm">/* We don't have to get the value to check the value.
    std also has holds_alternative: */</span>
    <span class="k">if</span> <span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">holds_alternative</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mVariant</span><span class="p">))</span> <span class="p">{</span>
        <span class="n">std</span><span class="o">::</span><span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="s">"variant holds a string"</span> <span class="o">&lt;&lt;</span> <span class="n">std</span><span class="o">::</span><span class="n">endl</span><span class="p">;</span>
    <span class="p">}</span>

    <span class="cm">/* We can also change the values other ways: */</span>
    <span class="n">mVariant</span><span class="p">.</span><span class="n">emplace</span><span class="o">&lt;</span><span class="mi">1</span><span class="o">&gt;</span><span class="p">(</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="p">(</span><span class="s">"emplace me"</span><span class="p">));</span>
    
    <span class="cm">/* Because get() returns a reference, we can do things like */</span>
    <span class="n">std</span><span class="o">::</span><span class="n">get</span><span class="o">&lt;</span><span class="n">std</span><span class="o">::</span><span class="n">string</span><span class="o">&gt;</span><span class="p">(</span><span class="n">mVariant</span><span class="p">)</span> <span class="o">+=</span> <span class="s">" append me"</span><span class="p">;</span>
<span class="p">}</span></code></pre></figure>

<p>I’d say that this is a much more mature and featured implementation of the choice type wanted.</p>

<p>There are a few great things about <code class="highlighter-rouge">std::variant</code>:</p>

<p>If you haven’t noticed, all the getters are type safe.</p>
<ul>
  <li>You can figure out the current type with <code class="highlighter-rouge">holds_alternative()</code> and <code class="highlighter-rouge">index()</code></li>
  <li>You don’t have to manually call constructors/destructors, even on non-trival types.</li>
  <li>There’s no extra memory allocation besides the one for std::variant itself, which can stay on the stack; no heap allocations except for the held object itself.</li>
</ul>

<h3 id="stdvisit">std::visit</h3>
<p><code class="highlighter-rouge">std::visit</code> is a function that applies a function, called a “Visitor”, on a <code class="highlighter-rouge">std::variant</code>. Visitors are used to</p>

<p>It’s easier to see in an example than it is to explain in words.</p>

<figure class="highlight"><pre><code class="language-cpp" data-lang="cpp"><span class="kt">int</span> <span class="nf">main</span><span class="p">()</span> <span class="p">{</span>
    <span class="k">auto</span> <span class="n">PrintVisitor</span> <span class="o">=</span> <span class="p">[](</span><span class="k">const</span> <span class="k">auto</span><span class="o">&amp;</span> <span class="n">type</span><span class="p">)</span> <span class="p">{</span> <span class="n">std</span><span class="o">::</span> <span class="n">cout</span> <span class="o">&lt;&lt;</span> <span class="n">type</span> <span class="o">&lt;&lt;</span> <span class="s">" visited"</span><span class="p">;</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">variant</span><span class="o">&lt;</span><span class="kt">int</span><span class="p">,</span> <span class="kt">double</span><span class="o">&gt;</span> <span class="n">mVariant</span> <span class="p">{</span> <span class="mi">1</span> <span class="p">};</span>
    <span class="n">std</span><span class="o">::</span><span class="n">visit</span><span class="p">(</span><span class="n">PrintVisitor</span><span class="p">,</span> <span class="n">mVariant</span><span class="p">);</span>  <span class="c1">// prints "1 visited"
</span>
    <span class="cm">/* We can selectively modify a variant based on its type through a struct */</span>
    <span class="k">struct</span> <span class="n">MathVisitor</span> <span class="p">{</span>
    	<span class="cm">/* if int value, multiply by 2. if float, multiply by 1.5 */</span>
        <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">int</span><span class="o">&amp;</span> <span class="n">i</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="n">i</span> <span class="o">*=</span> <span class="mi">2</span><span class="p">;</span>
        <span class="p">}</span>
        <span class="kt">void</span> <span class="k">operator</span><span class="p">()(</span><span class="kt">float</span><span class="o">&amp;</span> <span class="n">f</span><span class="p">)</span> <span class="k">const</span> <span class="p">{</span>
            <span class="n">f</span> <span class="o">*=</span> <span class="mf">1.5</span><span class="n">f</span><span class="p">;</span>
        <span class="p">}</span>
    <span class="p">}</span>
    <span class="n">std</span><span class="o">::</span><span class="n">visit</span><span class="p">(</span><span class="n">MathVisitor</span><span class="p">(),</span> <span class="n">mVariant</span><span class="p">);</span>  <span class="c1">// mVariant holds an int value of 2
</span>
    <span class="n">std</span><span class="o">::</span><span class="n">visit</span><span class="p">(</span><span class="n">PrintVisitor</span><span class="p">,</span> <span class="n">mVariant</span><span class="p">);</span>  <span class="c1">// prints "2 visited"</span></code></pre></figure>

<p>There’s only a few places <code class="highlighter-rouge">std::variant</code> actually comes into use that I can think of, so it’s not the most useful thing in the world. Only a few niche circumstances come to mind:</p>

<ul>
  <li>Error handling: returning either the success value or an error.</li>
  <li>Using them to handle an object that might be defined by a string name or int id</li>
  <li>???
I have some issues with the visitor function. It still feels a little clunky and verbose.  There’s still some refinement to be done here, but overall, I think <code class="highlighter-rouge">std::variant</code> and friends are a great replacement for <code class="highlighter-rouge">union</code>.</li>
</ul>


  </div><a class="u-url" href="/2020/01/14/cpp-variant.html" hidden></a>
</article>

      </div>
    </main><footer class="site-footer h-card">
  <data class="u-url" href="/"></data>

  <div class="wrapper">

    <h2 class="footer-heading">Programbling</h2>

    <div class="footer-col-wrapper">
      <div class="footer-col footer-col-1">
        <ul class="contact-list">
          <li class="p-name">Programbling</li><li><a class="u-email" href="mailto:taylor.he7@gmail.com">taylor.he7@gmail.com</a></li></ul>
      </div>

      <div class="footer-col footer-col-2"><ul class="social-media-list"><li><a href="https://github.com/taylorhe"><svg class="svg-icon"><use xlink:href="/assets/minima-social-icons.svg#github"></use></svg> <span class="username">taylorhe</span></a></li></ul>
</div>

      <div class="footer-col footer-col-3">
        <p>I ramble about programming and other topics.</p>
      </div>
    </div>

  </div>

</footer>
</body>

</html>
